---
title: React组件化高级开发技巧
date: 2023-08-01
tags:
  - React
author: qinghuanI
location: wuhan
---

## 查表法实现动态组件

- 两种情况直接使用三元表达式

两种情况的场景非常简单，一个三元表达式或者 `if... else` 可以解决，下面以项目中的例子说明

```jsx
const ActiveTab = () => {
  return (
    <>
      {mode === MODE_MAP.contact ? (
        <InteractionListByContact {...interactionListProps} interactionGroups={interactionGroups} />
      ) : null}
      {mode === MODE_MAP.channel ? (
        <InteractionListByChannel {...interactionListProps} interactions={channelInteractions} channels={channels} />
      ) : null}
    </>
  );
};
```

- 只有超过三种（包含三种）情况使用查表法才有意义

下面以 `webchat-sdk-ui` 项目为例

```tsx
const customComponentMap = {
  field: CustomField,
  dropdown: CustomDropdown,
  button: CustomButton,
  message: CustomMessage,
};

const InitialScreen: FC = (props: Props) => {
  return (
    <>
      {initialScreen?.controls.map((controlItem) => {
        const Component = customComponentMap[controlItem.type];

        return <></>;
      })}
    </>
  );
};
```

## 发布订阅模式

在软件架构中，发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在

## 一个组件只做一件事

一个组件只做一件事，这样可以让组件清爽。当发现组件越来越大时，我们就需要考虑是否可以将组件拆成多个组件，从而保证我们的每个组件只做一件事，保持组件的简洁和纯粹

## UI 与状态解耦

组件只做两件事，分别是数据展示和用户交互。当 UI 与状态解耦后，整个 React 组件会特别清爽

- 数据展示 - 从接口获取数据，然后正常显示
- 用户交互 - 接收用户交互，通过事件处理

```jsx
const Comp = () => {
  const { data, isLoading, error } = useSWR(key);

  const onChange = () => {
    setXXX();
    service.xxx();
  };

  return (
    <>
      <p>{data}</p>
      <input type="text" onChange={onChange} />
    </>
  );
};
```

## 业务 Hooks 与工具 Hooks

工具 Hooks 是与业务无关。这样的 Hooks 有很多，比如有项目中经常使用 `useClickAway` 检测特定组件之外的点击

```jsx
import { useEffect, useRef } from "react";

function useClickAway(cb) {
  const ref = useRef(null);
  const refCb = useRef(cb);

  useEffect(() => {
    const handler = (e) => {
      const element = ref.current;
      if (element && !element.contains(e.target)) {
        refCb.current(e);
      }
    };

    document.addEventListener("mousedown", handler);
    document.addEventListener("touchstart", handler);

    return () => {
      document.removeEventListener("mousedown", handler);
      document.removeEventListener("touchstart", handler);
    };
  }, []);

  return ref;
}

export default useClickAway;
```

`useClickAway` 与业务没有关系，它可以在任何需要它的使用场景中使用

与工具 Hooks 相对的就是 业务 Hooks, 既然是业务 Hooks 肯定与业务高耦合

6. 与 IO 相关的错误处理
7. 接口依赖

## 内存释放

前端存在内存泄露的场景总结：

- 未及时清理定时器
- 未移除事件监听

## 状态管理与 Flux 架构

组件是逻辑和状态（数据状态、UI 状态）的封装。React 组件本质上是函数，函数会创建函数作用域，函数体的状态和逻辑的生命周期只存在函数内部，所以组件具有天然的状态隔离性，相当于组件是独立封闭的单元

而在 SPA 应用中，页面上的功能由许多组件组合而成。在这个过程中，多个组件之间不可避免的要共享某些状态。为了实现这些功能，就需要打破组件的状态隔离性，让状态在这些组件内流转，加强组件之间的关联性。这个过程就是组件通信

一个成熟的系统，既要有输入，也要有输出

## 防抖与节流

## Effect、Event 和 useEffectEvent

- useEffect - 由某些状态变化触发，而不是某些行为触发

```jsx
useEffect(() => {
  document.title = title;
}, [title]);
```

- Event - 由某些行为触发，而不是某些状态触发

```jsx
const handleClick = () => setCount(10);

<button onClick={handleClick}>click</button>;
```

- useEffectEvent - 在 Effect 内执行，但是 Effect 并不依赖其中状态的逻辑

```jsx
const onConnected = useEffectEvent(() => {});

useEffect(() => {
  connection.on("connect", () => {
    onConnected();
  });
}, []);
```

## 组件懒加载

## 可变数据与不可变数据

## useMemo、useCallback 与组件重渲染

## 数据竟态

## 动态样式
